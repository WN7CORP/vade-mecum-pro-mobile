
import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import { ArticleData } from './googleApi';

// Function to export articles to PDF
export async function exportToPdf(
  articles: ArticleData[], 
  filename = 'vade-mecum-export.pdf',
  explanations: Record<string, string> = {}
): Promise<string> {
  try {
    // Create a new PDF document
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });
    
    // Set document properties
    pdf.setProperties({
      title: 'Vade Mecum Pro - Exportação',
      subject: 'Artigos jurídicos exportados',
      author: 'Vade Mecum Pro',
      creator: 'Vade Mecum Pro 2025'
    });
    
    // Add header to the PDF
    pdf.setFontSize(20);
    pdf.setFont('times', 'bold');
    pdf.setTextColor(26, 54, 93); // Deep navy color
    pdf.text('Vade Mecum Pro', 105, 20, { align: 'center' });
    
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(12);
    pdf.setTextColor(100, 100, 100);
    pdf.text('Exportação de Artigos', 105, 28, { align: 'center' });
    
    // Add current date
    const currentDate = new Date().toLocaleDateString('pt-BR');
    pdf.setFontSize(10);
    pdf.text(`Data: ${currentDate}`, 20, 40);
    
    let yPosition = 50;
    
    // Add each article to the PDF
    for (const article of articles) {
      // Check if we need a new page
      if (yPosition > 250) {
        pdf.addPage();
        yPosition = 20;
      }
      
      // Add article number in bold
      pdf.setFontSize(16);
      pdf.setFont('times', 'bold');
      pdf.setTextColor(26, 54, 93);
      pdf.text(`Artigo ${article.articleNumber}`, 20, yPosition);
      yPosition += 10;
      
      // Add article text with line breaks
      pdf.setFont('times', 'normal');
      pdf.setTextColor(0, 0, 0);
      pdf.setFontSize(11);
      
      // Split text into lines with wordwrap and preserve line breaks
      const textWithPreservedLineBreaks = article.articleText.replace(/\n/g, '\r\n');
      const textLines = pdf.splitTextToSize(textWithPreservedLineBreaks, 170);
      
      // Add each line
      for (const line of textLines) {
        pdf.text(line, 20, yPosition);
        yPosition += 6;
        
        // Check if we need a new page
        if (yPosition > 280) {
          pdf.addPage();
          yPosition = 20;
        }
      }
      
      // Add explanation if available
      const explanation = explanations[article.articleNumber];
      if (explanation) {
        // Add spacing before explanation
        yPosition += 10;
        
        // Check if we need a new page
        if (yPosition > 250) {
          pdf.addPage();
          yPosition = 20;
        }
        
        // Add explanation header
        pdf.setFontSize(13);
        pdf.setFont('helvetica', 'bold');
        pdf.setTextColor(245, 158, 11); // Gold color
        pdf.text('Explicação do Artigo', 20, yPosition);
        yPosition += 8;
        
        // Add explanation text
        pdf.setFont('helvetica', 'normal');
        pdf.setTextColor(0, 0, 0);
        pdf.setFontSize(10);
        
        const explanationLines = pdf.splitTextToSize(explanation, 170);
        
        // Add each explanation line
        for (const line of explanationLines) {
          pdf.text(line, 20, yPosition);
          yPosition += 5;
          
          // Check if we need a new page
          if (yPosition > 280) {
            pdf.addPage();
            yPosition = 20;
          }
        }
        
        // Add "Generated by AI" note
        yPosition += 5;
        pdf.setFontSize(8);
        pdf.setTextColor(100, 100, 100);
        pdf.setFont('helvetica', 'italic');
        pdf.text('Gerado por IA utilizando Gemini', 170, yPosition, { align: 'right' });
        
        yPosition += 10;
      } else {
        // Add spacing between articles
        yPosition += 15;
      }
      
      // Add a separator line between articles if this is not the last article
      if (articles.indexOf(article) < articles.length - 1) {
        pdf.setDrawColor(220, 220, 220);
        pdf.line(20, yPosition - 5, 190, yPosition - 5);
      }
    }
    
    // Footer
    pdf.setFont('helvetica', 'italic');
    pdf.setFontSize(8);
    pdf.setTextColor(100, 100, 100);
    pdf.text('Documento gerado por Vade Mecum Pro 2025', 105, 290, { align: 'center' });
    
    // Save and return the PDF as base64 string
    const pdfOutput = pdf.output('datauristring');
    
    return pdfOutput;
  } catch (error) {
    console.error('Error exporting to PDF:', error);
    throw new Error('Failed to export articles to PDF');
  }
}

// Function to export element to PDF (for single article)
export async function exportElementToPdf(element: HTMLElement, filename = 'vade-mecum-article.pdf'): Promise<string> {
  try {
    const canvas = await html2canvas(element, {
      scale: 2,
      useCORS: true,
      logging: false
    });
    
    const imgData = canvas.toDataURL('image/png');
    
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });
    
    // Add header
    pdf.setFontSize(16);
    pdf.setFont('times', 'bold');
    pdf.setTextColor(26, 54, 93);
    pdf.text('Vade Mecum Pro', 105, 15, { align: 'center' });
    
    // Calculate dimensions to fit the image properly
    const imgWidth = 190;  // A4 width minus margins
    const pageHeight = 297; // A4 height in mm
    const imgHeight = (canvas.height * imgWidth) / canvas.width;
    
    // Add the image
    pdf.addImage(imgData, 'PNG', 10, 20, imgWidth, imgHeight);
    
    // Add footer
    pdf.setFont('helvetica', 'italic');
    pdf.setFontSize(8);
    pdf.setTextColor(100, 100, 100);
    pdf.text('Documento gerado por Vade Mecum Pro 2025', 105, 290, { align: 'center' });
    
    // Save and return the PDF as base64 string
    const pdfOutput = pdf.output('datauristring');
    
    return pdfOutput;
  } catch (error) {
    console.error('Error exporting element to PDF:', error);
    throw new Error('Failed to export element to PDF');
  }
}

// Prepare data for Google Sheets export
export function prepareDataForSheets(
  articles: ArticleData[], 
  annotations: Record<string, string> = {},
  highlights: Record<string, string[]> = {}
): any[][] {
  // Create header row
  const headers = ['Número do Artigo', 'Texto do Artigo', 'Anotação Pessoal', 'Destaques', 'Data'];
  
  // Create data rows
  const rows = articles.map(article => {
    return [
      article.articleNumber,
      article.articleText,
      annotations[article.articleNumber] || '',
      (highlights[article.articleNumber] || []).join('\n'),
      new Date().toLocaleDateString('pt-BR')
    ];
  });
  
  // Return combined data (header + rows)
  return [headers, ...rows];
}

// Function to handle Google Sheets export
// This is a placeholder as the actual implementation would require OAuth authentication
export function exportToGoogleSheets(data: any[][]): void {
  console.log('Google Sheets export functionality requires OAuth implementation');
  console.log('Data prepared for export:', data);
  
  // In a complete implementation, this would:
  // 1. Authenticate user with OAuth
  // 2. Create a new spreadsheet or open an existing one
  // 3. Write the data to the spreadsheet
  // 4. Share the spreadsheet if needed
}
